## given 2 strings, calculates the minimum edit distance
#def get_change_cost(a, b):
#    n = len(a)+1
#    m = len(b)+1
#    # create matrix of n+1 rows, m+1 columns
#    table = numpy.zeros((n, m), dtype=numpy.int)
#    # matrix set up for when comparing empty strings
#    for i in range(1, n):
#        table[i][0] = get_str_cost(a, i-1)
#    for j in range(1, m):
#        table[0][j] = get_str_cost(b, j-1)
#    
#    for i in range(1, n):
#        for j in range(1, m):
#            table[i][j] = table[i-1][j-1]
#            if a[i-1] is not b[j-1]:
#                table[i][j] = table[i][j-1] + table[i-1][j] - table[i-1][j-1]
#
#    return table[n-1][m-1]

#def find_change(t, n, m, a, b):
#    added = []
#    edit_dist = t[n][m]
#    diag_edit = t[n-1][m-1]
#    left_edit = t[n][m-1]
#    top_edit = t[n-1][m-1]
#    if edit_dist == diag_edit:
#        if (left_edit >= diag_edit <= top_edit):
#            find_change(t, n-1, m-1)
#        elif (left_edit < diag_edit):
#            deleted.append(a[n])
#                find_change(
#        elif (top_edit < diag_edit):
#            added.append(

#def get_str_cost(str, i):
#    cost = 0
#    for j in str[:i+1]:
#        if j in 'aeiou':
#            cost += 1
#        else:
#            cost += 5
#    return cost
#
#def get_cost(char):
#    if char in 'aeiou':
#        return 1
#    return 5
#
#def find_diff(orig, goal):
#    result = traverse(orig, goal, [], [])
#    a = result[0]
#    b = result[1]
#    
#    cost = 0
#    for c in a+d:
#        cost += get_cost(c)
#    return cost
#
#def traverse(orig, goal, added, deleted):
#    if orig and goal:
#        c1 = orig[0]
#        c2 = goal[0]
#        if c1 is not c2:
#            print 'hi'
#            cost_o = get_cost(c1)
#            cost_g = get_cost(c2)
#            if cost_g <= cost_o:
#                added.append(c2)
#                traverse(orig, goal.lstrip(c2), added, deleted)
#            else:
#                deleted.append(c1)
#                traverse(orig.lstrip(c1), goal, added, deleted)
#        else:
#            traverse(orig.lstrip(c1), goal.lstrip(c2), added, deleted)
#    else:
#        return [added, deleted]
def contains_chars(pairs):
    (string, image) = pairs
    flag = 1
    for c in string:
        if c in image:
            x = image.find(c)
            if x < len(image)-1:
                image = image[x+1:]
                continue
            elif c is string[-1]:
                break
            else:
                return 0
        else:
            return 0
    return flag
    
    
# in case we couldn't find images the first time, we'll try again
# and go a little deeper in our search
def try_again(goal):
    more_cands = []
    max_lcs = 0
    min_cand_cost = get_str_cost(goal)
    images_copy = copy.copy(images)
    contains_goal = filter(lambda x: contains_chars(goal, x, False), images_copy)
    for cand in contains_goal:
        images_copy.remove(cand)
        no_goal = filter(lambda x: not contains_chars(goal, x, True) and contains_chars(x, cand, False), images_copy)
        if no_goal:
            mapped_lcs = [do_lcs(cand, n) for n in no_goal]
            cands = filter(lambda x: x.get_lcs_value() >= len(goal), mapped_lcs)
            for new_lcs in cands:
                lcs_value = new_lcs.get_lcs_value()
                right = new_lcs.orig
                for char in goal:
                    new_lcs.inserted.remove(char)
                new_cost = get_str_cost(''.join(new_lcs.inserted))
                if lcs_value > max_lcs and new_cost < min_cand_cost:
                    max_lcs = lcs_value
                    min_cand_cost = new_cost
                    more_cands.append(':' + cand + ' - :' + right + ' - ' + ''.join(new_lcs.inserted))
    if not more_cands:
        more_cands.append(goal)
    result = sorted(more_cands, key=len)
    return result[0]
    
    
#         if change_cost != 0:
#             if not ins_cand[0].startswith(':') and del_cand[0].startswith(':'):
#                 ins_cand = try_again(''.join(ins_cand[0]))
#                 del_cand = del_cand[0]
#             elif ins_cand[0].startswith(':') and not del_cand[0].startswith(':'):
#                 ins_cand = ins_cand[0]
#                 del_cand = try_again(''.join(del_cand[0]))
#             else:
#                 ins_cand = try_again(''.join(ins_cand[0]))
#                 del_cand = try_again(''.join(del_cand[0]))
#             new_cost = get_expr_cost(ins_cand) + get_expr_cost(del_cand)
#             if new_cost < cost:
#                 root = lcs.orig
#                 ins_result = ins_cand
#                 del_result = del_cand
#                 cost = new_cost
#         else:
#             root = lcs.orig
#             ins_result = ins_cand[0]
#             del_result = del_cand[0]
#             cost = 0
#             break


            more_cands = []
            max_lcs = 0
            min_cand_cost = get_str_cost(goal)
            images_copy = copy.copy(images)
            for cand in contains_goal:
                images_copy.remove(cand)
                no_goal = filter(lambda x: not contains_chars(goal, x, True) and contains_chars(x, cand, False), images_copy)
                new_lcs_list = []
                for n in no_goal:
                    for l in lcs_list:
                        if l.orig is n and l.get_lcs_value >= len(goal):
                            new_lcs_list.append(l)
                for lcs in new_lcs_list:
                    for char in goal:
                        lcs.inserted.remove(char)
                    lcs_value = lcs.get_lcs_value()
                    new_cost = get_str_cost(''.join(lcs.inserted))
                    if lcs_value > max_lcs and new_cost < min_cand_cost:
                        right = lcs.orig
                        max_lcs = lcs_value
                        min_cand_cost = new_cost
                        more_cands.append(':' + cand + ' - :' + right + ' - ' + ''.join(lcs.inserted))
            if more_cands:
                results = more_cands
            else:
